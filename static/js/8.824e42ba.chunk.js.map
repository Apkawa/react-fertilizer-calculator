{"version":3,"sources":["../home/runner/work/react-sortablejs/react-sortablejs/node_modules/@parcel/scope-hoisting/lib/helpers.js","util.ts","react-sortable.tsx","../node_modules/classnames/index.js","../../../utils/src/browser-info.ts","../../../utils/src/utils.ts","../../../sortable/src/PluginManager.ts","../../../sortable/src/EventDispatcher.ts","../../../sortable/src/Sortable.ts","../../../plugins/swap/src/index.ts","../../../sortable/src/Animation.ts","../../../plugins/multi-drag/src/index.ts","../../../plugins/on-spill/src/index.ts","../../../plugins/auto-scroll/src/index.ts","../../src/modular-complete.ts","../node_modules/@styled-icons/fa-regular/Edit/Edit.esm.js","../node_modules/@styled-icons/fa-solid/Trash/Trash.esm.js"],"names":["$parcel$interopDefault","a","__esModule","default","removeNode","node","parentElement","removeChild","removeNodes","customs","forEach","curr","element","insertNodes","parent","newChild","index","refChild","oldIndex","children","insertBefore","createCustoms","evt","list","mode","getMode","from","custom","item","newIndex","$bf037e368b3040002dda64d69d3f$var$_objectSpread","swapItem","oldIndicies","map","multiDragElement","newIndicies","inputs","sort","b","handleStateRemove","normalized","newList","$bf037e368b3040002dda64d69d3f$var$_toConsumableArray","concat","reverse","splice","handleStateAdd","clone","newItem","length","store","dragging","ReactSortable","Component","props","_this","ref","createRef","chosen","selected","setList","sortable","invariant","plugins","this","current","newOptions","makeOptions","Sortable","create","tag","classicProps","style","className","id","createElement","$ff006f4a88ed11a8119708ec3f19c5db$var$_objectSpread","getChildren","dataIdAttr","selectedClass","chosenClass","dragClass","fallbackClass","ghostClass","swapClass","filter","dataid","Children","child","prevClassName","filtered","$ff006f4a88ed11a8119708ec3f19c5db$var$_defineProperty","replace","classNames","cloneElement","key","onAdd","onChange","onChoose","onClone","onEnd","onFilter","onRemove","onSort","onStart","onUnchoose","onUpdate","onMove","onSpill","onSelect","onDeselect","$bf037e368b3040002dda64d69d3f$var$_objectWithoutProperties","name","_this2","prepareOnHandlerPropAndDOM","prepareOnHandlerProp","originalEvt","defaultValue","willInsertAfter","result","evtName","_this3","callOnHandlerProp","_this4","propEvent","$bf037e368b3040002dda64d69d3f$export$createCustoms","$ff006f4a88ed11a8119708ec3f19c5db$var$_toConsumableArray","$bf037e368b3040002dda64d69d3f$export$removeNodes","$bf037e368b3040002dda64d69d3f$export$handleStateAdd","$bf037e368b3040002dda64d69d3f$export$getMode","$bf037e368b3040002dda64d69d3f$export$insertNodes","pullMode","$bf037e368b3040002dda64d69d3f$export$handleStateRemove","customClones","clones","_this5","removeOnSpill","revertOnSpill","$bf037e368b3040002dda64d69d3f$export$removeNode","console","log","type","el","Object","keys","find","k","includes","hasOwn","hasOwnProperty","classes","i","arguments","arg","argType","push","Array","isArray","inner","apply","call","join","module","exports","userAgent","pattern","window","navigator","match","IE11OrLess","Edge","FireFox","Safari","IOS","ChromeForAndroid","captureMode","capture","passive","on","event","fn","addEventListener","off","removeEventListener","matches","selector","substring","msMatchesSelector","webkitMatchesSelector","_","getParentOrHost","host","document","nodeType","parentNode","closest","ctx","includeCTX","_throttleTimeout","R_SPACE","toggleClass","state","classList","css","prop","val","defaultView","getComputedStyle","currentStyle","indexOf","matrix","selfOnly","appliedTransforms","transform","matrixFn","DOMMatrix","WebKitCSSMatrix","CSSMatrix","MSCSSMatrix","tagName","iterator","getElementsByTagName","n","getWindowScrollingElement","scrollingElement","documentElement","getRect","relativeToContainingBlock","relativeToNonStaticParent","undoScale","container","getBoundingClientRect","elRect","top","left","bottom","right","height","width","innerHeight","innerWidth","containerRect","parseInt","elMatrix","scaleX","scaleY","d","isScrolledPast","elSide","parentSide","getParentAutoScrollElement","elSideVal","parentSideVal","getChild","childNum","options","currentChild","display","ghost","dragged","draggable","lastChild","last","lastElementChild","previousElementSibling","nodeName","toUpperCase","getRelativeScrollOffset","offsetLeft","offsetTop","winScroller","scrollLeft","scrollTop","includeSelf","elem","gotSelf","clientWidth","scrollWidth","clientHeight","scrollHeight","elemCSS","overflowX","overflowY","body","isRectEqual","rect1","rect2","Math","round","throttle","callback","ms","args","setTimeout","scrollBy","x","y","Polymer","$","jQuery","Zepto","dom","cloneNode","setRect","rect","unsetRect","expando","Date","getTime","defaults","initializeByDefault","pluginManager","mount","plugin","option","pluginEvent","eventName","eventCanceled","cancel","eventNameGlobal","pluginName","initializePlugins","initialized","assign","modified","modifyOption","getEventProperties","eventProperties","value","modifiedValue","optionListeners","dispatchEvent","rootEl","targetEl","cloneEl","toEl","fromEl","oldDraggableIndex","newDraggableIndex","originalEvent","putSortable","extraEventProperties","onName","charAt","substr","CustomEvent","createEvent","initEvent","bubbles","cancelable","to","lastPutMode","allEventProperties","PluginManager","data","bind","dragEl","parentEl","ghostEl","nextEl","lastDownEl","cloneHidden","dragStarted","moved","activeSortable","active","hideGhostForTarget","_hideGhostForTarget","unhideGhostForTarget","_unhideGhostForTarget","cloneNowHidden","cloneNowShown","dispatchSortableEvent","_dispatchEvent","info","activeGroup","tapEvt","touchEvt","lastDx","lastDy","tapDistanceLeft","tapDistanceTop","lastTarget","lastDirection","targetMoveDistance","ghostRelativeParent","awaitingDragStarted","ignoreNextClick","sortables","pastFirstInvertThresh","isCircumstantialInvert","ghostRelativeParentInitialScroll","_silent","savedInputChecked","documentExists","PositionGhostAbsolutely","CSSFloatProperty","supportDraggable","supportCssPointerEvents","cssText","pointerEvents","_detectDirection","elCSS","elWidth","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","child1","child2","firstChildCSS","secondChildCSS","firstChildWidth","marginLeft","marginRight","secondChildWidth","flexDirection","gridTemplateColumns","split","clear","_prepareGroup","toFn","pull","group","otherGroup","originalGroup","checkPull","checkPut","put","revertClone","preventDefault","stopPropagation","stopImmediatePropagation","lastSwapEl","nearestEmptyInsertDetectEvent","nearest","touches","clientX","clientY","some","threshold","emptyInsertThreshold","ret","target","_onDragOver","_checkOutsideTargetEl","_isOutsideThisEl","toString","animationCallbackId","animationStates","disabled","handle","test","swapThreshold","invertSwap","invertedSwapThreshold","removeCloneOnHide","direction","ignore","preventOnFilter","animation","easing","setData","dataTransfer","textContent","dropBubble","dragoverBubble","delay","delayOnTouchOnly","touchStartThreshold","Number","devicePixelRatio","forceFallback","fallbackOnBody","fallbackTolerance","fallbackOffset","supportPointer","nativeDraggable","_onTapStart","get","captureAnimationState","slice","fromRect","thisAnimationDuration","childMatrix","f","e","addAnimationState","removeAnimationState","arr","obj","animateAll","clearTimeout","animating","animationTime","time","toRect","prevFromRect","prevToRect","animatingRect","targetMatrix","sqrt","pow","animate","max","animationResetTimer","currentRect","duration","translateX","translateY","animatingX","animatingY","forRepaintDummy","offsetWidth","animated","dragRect","targetRect","retVal","onMoveFn","draggedRect","related","relatedRect","_disableDraggable","_unsilent","_generateId","str","src","href","sum","charCodeAt","_nextTick","_cancelNextTick","prototype","constructor","contains","_getDirection","touch","pointerType","originalTarget","shadowRoot","path","composedPath","root","idx","checked","button","isContentEditable","criteria","trim","_prepareDragStart","dragStartFn","ownerDocument","nextSibling","_lastX","_lastY","_onDrop","_disableDelayedDragEvents","_triggerDragStart","_disableDelayedDrag","_delayedDragTouchMoveHandler","_dragStartTimer","abs","floor","_onTouchMove","_onDragStart","selection","empty","getSelection","removeAllRanges","err","_dragStarted","fallback","_appendGhost","_nulling","_emulateDragOver","elementFromPoint","ghostMatrix","relativeScrollOffset","dx","dy","c","cssMatrix","appendChild","_hideClone","cloneId","_loopId","setInterval","effectAllowed","_dragStartId","revert","vertical","isOwner","canSort","fromSortable","completedFired","dragOverEvent","_ignoreWhileAnimating","completed","elLastChild","changed","targetBeforeFirstSwap","sibling","differentLevel","differentRowCol","dragElS1Opp","targetS1Opp","side1","scrolledPastTop","scrollBefore","isLastTarget","mouseOnAxis","targetLength","targetS1","targetS2","invert","dragIndex","nextElementSibling","after","moveVector","extra","axis","insertion","_showClone","_offMoveEvents","_offUpEvents","clearInterval","save","handleEvent","dropEffect","toArray","order","getAttribute","items","set","destroy","querySelectorAll","removeAttribute","utils","is","extend","dst","nextTick","cancelNextTick","detectDirection","version","lastMultiDragSelect","multiDragSortable","clonesFromRect","clonesHidden","multiDragElements","multiDragClones","initialFolding","folding","insertMultiDragClones","elementsInserted","sortableIndex","removeMultiDragElements","drop","toSortable","changedTouches","Revert","Remove","startIndex","dragStart","parentSortable","scrollEl","scrollRootEl","lastAutoScrollX","lastAutoScrollY","pointerElemChangedInterval","autoScrolls","scrolling","clearAutoScrolls","autoScroll","pid","clearPointerElemChangedInterval","isFallback","scroll","scrollCustomFn","sens","scrollSensitivity","speed","scrollSpeed","scrollThisInstance","scrollFn","layersOut","currentParent","canScrollX","canScrollY","scrollPosX","scrollPosY","vx","vy","layer","scrollOffsetY","scrollOffsetX","bubbleScroll","AutoScroll","_handleAutoScroll","_handleFallbackAutoScroll","dragOverCompleted","dragOverBubble","nulling","ogElemScroller","newElem","RemoveOnSpill","RevertOnSpill","Swap","dragOverValid","swap","prevSwapEl","n1","n2","i1","i2","p1","p2","isEqualNode","MultiDrag","_deselectMultiDrag","_checkKeyDown","_checkKeyUp","multiDragKey","multiDragKeyDown","isMultiDrag","delayStartGlobal","delayEnded","setupClone","t","showClone","hideClone","dragStartGlobal","multiDrag","dragOver","clonesInserted","dragRectAbsolute","clonesHiddenBefore","dragOverAnimationCapture","dragMatrix","dragOverAnimationComplete","shiftKey","lastIndex","currentIndex","multiDragIndex","update","nullingGlobal","destroyGlobal","shift","select","deselect","toLowerCase","Edit","React","StyledIconBase","_extends","iconAttrs","iconVerticalAlign","iconViewBox","fill","displayName","Trash"],"mappings":"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","file":"static/js/8.824e42ba.chunk.js","sourcesContent":[null,"import { PropsWithChildren } from \"react\";\nimport Sortable, { Options } from \"sortablejs\";\nimport { MultiDragEvent } from \"./react-sortable\";\nimport { AllMethodNames, ItemInterface, ReactSortableProps } from \"./types\";\n\n/**\n * Removes the `node` from the DOM\n * @param node\n */\nexport function removeNode(node: HTMLElement): void {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\n\n/**\n * Inserts the `newChild` node at the given index in a parent\n * @param parent The parent HTML Element.\n * @param newChild A HTML eement to add as a child of the parent.\n * @param index index of the parent to place the new child in.\n */\nexport function insertNodeAt(\n  parent: HTMLElement,\n  newChild: HTMLElement,\n  index: number\n): void {\n  const refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\n\n// @todo - create a dom handler function for arrays or not at all\n\n/** removes stuff from the dom in a nice order */\n// @todo - do I need parenElement?\nexport function handleDOMChanges<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  removeNodes(customs);\n  insertNodes(customs);\n}\n\nexport function removeNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => removeNode(curr.element));\n}\n\nexport function insertNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => {\n    insertNodeAt(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\n\nexport function createCustoms<T extends ItemInterface>(\n  evt: MultiDragEvent,\n  list: T[]\n): Normalized<T>[] {\n  const mode = getMode(evt);\n  const parentElement = { parentElement: evt.from };\n  let custom = [];\n  switch (mode) {\n    case \"normal\":\n      /* eslint-disable */\n      const item = {\n        element: evt.item,\n        newIndex: evt.newIndex!,\n        oldIndex: evt.oldIndex!,\n        parentElement: evt.from,\n      };\n      custom = [item];\n      break;\n    case \"swap\":\n      const drag: Input = {\n        element: evt.item,\n        oldIndex: evt.oldIndex!,\n        newIndex: evt.newIndex!,\n        ...parentElement,\n      };\n      const swap: Input = {\n        element: evt.swapItem!,\n        oldIndex: evt.newIndex!,\n        newIndex: evt.oldIndex!,\n        ...parentElement,\n      };\n      custom = [drag, swap];\n      break;\n    case \"multidrag\":\n      custom = evt.oldIndicies.map<Input>((curr, index) => ({\n        element: curr.multiDragElement,\n        oldIndex: curr.index,\n        newIndex: evt.newIndicies[index].index,\n        ...parentElement,\n      }));\n      break;\n  }\n  /* eslint-enable */\n\n  const customs = createNormalized(custom, list);\n  return customs;\n}\n\n/** moves items form old index to new index without breaking anything ideally. */\nexport function handleStateChanges<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const a = handleStateRemove(normalized, list);\n  const b = handleStateAdd(normalized, a);\n  return b;\n}\n\nexport function handleStateRemove<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const newList = [...list];\n  normalized\n    .concat()\n    .reverse()\n    .forEach((curr) => newList.splice(curr.oldIndex, 1));\n  return newList;\n}\n\nexport function handleStateAdd<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[],\n  evt?: Sortable.SortableEvent,\n  clone?: ((currentItem: T, evt: Sortable.SortableEvent) => T) | undefined\n): T[] {\n  const newList = [...list];\n  normalized.forEach((curr) => {\n    const newItem = clone && evt && clone(curr.item, evt);\n    newList.splice(curr.newIndex, 0, newItem || curr.item);\n  });\n  return newList;\n}\n\nexport function getMode(evt: MultiDragEvent): \"multidrag\" | \"swap\" | \"normal\" {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\n\nexport function createNormalized<T extends ItemInterface>(\n  inputs: Input[],\n  list: T[]\n): Normalized<T>[] {\n  const normalized = inputs\n    .map<Normalized<T>>((curr) => ({ ...curr, item: list[curr.oldIndex] }))\n    .sort((a, b) => a.oldIndex - b.oldIndex);\n  return normalized;\n}\n\nexport interface Input {\n  parentElement: HTMLElement;\n  element: HTMLElement;\n  oldIndex: number;\n  newIndex: number;\n}\n\nexport interface Normalized<T> extends Input {\n  item: T;\n}\n\n/**\n * Removes the following group of properties from `props`,\n * leaving only `Sortable.Options` without any `on` methods.\n * @param props `ReactSortable.Props`\n */\nexport function destructurePropsForOptions<T>(\n  props: PropsWithChildren<ReactSortableProps<T>>\n): Exclude<Options, AllMethodNames> {\n  /* eslint-disable */\n  const {\n    // react sortable props\n    list,\n    setList,\n    children,\n    tag,\n    style,\n    className,\n    clone,\n    // sortable options that have methods we want to overwrite\n    onAdd,\n    onChange,\n    onChoose,\n    onClone,\n    onEnd,\n    onFilter,\n    onRemove,\n    onSort,\n    onStart,\n    onUnchoose,\n    onUpdate,\n    onMove,\n    onSpill,\n    onSelect,\n    onDeselect,\n    ...options\n  } = props;\n  /* eslint-enable */\n  return options;\n}\n\n/**\n * Construct a type with the properties of T except for those in type K.\n * Including this allows for backwards compatibility with earlier versions of TS.\n */\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n","import classNames from \"classnames\";\nimport {\n  Children,\n  cloneElement,\n  Component,\n  createElement,\n  createRef,\n  ReactElement,\n  RefObject,\n} from \"react\";\nimport Sortable, { MoveEvent, Options, SortableEvent } from \"sortablejs\";\nimport invariant from \"tiny-invariant\";\nimport {\n  AllMethodsExceptMove,\n  HandledMethodNames,\n  ItemInterface,\n  ReactSortableProps,\n  Store,\n  UnHandledMethodNames,\n} from \"./types\";\nimport {\n  createCustoms,\n  destructurePropsForOptions,\n  getMode,\n  handleStateAdd,\n  handleStateChanges,\n  handleStateRemove,\n  insertNodes,\n  removeNode,\n  removeNodes,\n} from \"./util\";\n\n/** Holds a global reference for which react element is being dragged */\n// @todo - use context to manage this. How does one use 2 different providers?\nconst store: Store = { dragging: null };\n\nexport class ReactSortable<T extends ItemInterface> extends Component<\n  ReactSortableProps<T>\n> {\n  /* eslint-disable-next-line */\n  static defaultProps: Partial<ReactSortableProps<any>> = {\n    clone: (item) => item,\n  };\n\n  private ref: RefObject<HTMLElement>;\n  constructor(props: ReactSortableProps<T>) {\n    super(props);\n    // @todo forward ref this component\n    this.ref = createRef<HTMLElement>();\n\n    // make all state false because we can't change sortable unless a mouse gesture is made.\n    const newList = props.list.map((item) => ({\n      ...item,\n      chosen: false,\n      selected: false,\n    }));\n\n    props.setList(newList, this.sortable, store);\n    invariant(\n      //@ts-expect-error: Doesn't exist. Will deprecate soon.\n      !props.plugins,\n      `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `\n    );\n  }\n  componentDidMount(): void {\n    if (this.ref.current === null) return;\n    const newOptions = this.makeOptions();\n    Sortable.create(this.ref.current, newOptions);\n  }\n\n  render(): JSX.Element {\n    const { tag, style, className, id } = this.props;\n    const classicProps = { style, className, id };\n\n    // if no tag, default to a `div` element.\n    const newTag = !tag || tag === null ? \"div\" : tag;\n    return createElement(\n      newTag,\n      {\n        // @todo - find a way (perhaps with the callback) to allow AntD components to work\n        ref: this.ref,\n        ...classicProps,\n      },\n      this.getChildren()\n    );\n  }\n\n  private getChildren() {\n    const {\n      children,\n      dataIdAttr,\n      selectedClass = \"sortable-selected\",\n      chosenClass = \"sortable-chosen\",\n      /* eslint-disable */\n      dragClass = \"sortable-drag\",\n      fallbackClass = \"sortable-falback\",\n      ghostClass = \"sortable-ghost\",\n      swapClass = \"sortable-swap-highlight\",\n      /* eslint-enable */\n      filter = \"sortable-filter\",\n      list,\n    } = this.props;\n\n    // if no children, don't do anything.\n    if (!children || children == null) return null;\n    const dataid = dataIdAttr || \"data-id\";\n    /* eslint-disable-next-line */\n    return Children.map(children as ReactElement<any>[], (child, index) => {\n      const item = list[index];\n      const { className: prevClassName } = child.props;\n\n      // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n      const filtered = typeof filter === \"string\" && {\n        [filter.replace(\".\", \"\")]: !!item.filtered,\n      };\n\n      const className = classNames(prevClassName, {\n        [selectedClass]: item.selected,\n        [chosenClass]: item.chosen,\n        ...filtered,\n        // [dragClass]: true,\n        // [fallbackClass]: true,\n        // [ghostClass]: true,\n        // [swapClass]: true\n      });\n\n      return cloneElement(child, {\n        [dataid]: child.key,\n        className,\n      });\n    });\n  }\n\n  /** Appends the `sortable` property to this component */\n  private get sortable(): Sortable | null {\n    const el = this.ref.current;\n    if (el === null) return null;\n    const key = Object.keys(el).find((k) => k.includes(\"Sortable\"));\n    if (!key) return null;\n    //@ts-expect-error: fix me.\n    return el[key] as Sortable;\n  }\n\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n  makeOptions(): Options {\n    const DOMHandlers: HandledMethodNames[] = [\n      \"onAdd\",\n      \"onChoose\",\n      \"onDeselect\",\n      \"onEnd\",\n      \"onRemove\",\n      \"onSelect\",\n      \"onSpill\",\n      \"onStart\",\n      \"onUnchoose\",\n      \"onUpdate\",\n    ];\n    const NonDOMHandlers: UnHandledMethodNames[] = [\n      \"onChange\",\n      \"onClone\",\n      \"onFilter\",\n      \"onSort\",\n    ];\n    const newOptions: Options = destructurePropsForOptions(this.props);\n    DOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerPropAndDOM(name))\n    );\n    NonDOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerProp(name))\n    );\n\n    /** onMove has 2 arguments and needs to be handled seperately. */\n    const onMove = (evt: MoveEvent, originalEvt: Event) => {\n      const { onMove } = this.props;\n      const defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      const result = onMove(evt, originalEvt, this.sortable, store);\n      if (typeof result === \"undefined\") return false;\n      return result;\n    };\n\n    return {\n      ...newOptions,\n      onMove,\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n  prepareOnHandlerPropAndDOM(\n    evtName: HandledMethodNames\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n      // calls state change\n      //@ts-expect-error: until @types multidrag item is in\n      this[evtName](evt);\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n  prepareOnHandlerProp(\n    evtName: Exclude<AllMethodsExceptMove, HandledMethodNames>\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n    };\n  }\n\n  /** Calls the `props.on[Handler]` function */\n  callOnHandlerProp(evt: SortableEvent, evtName: AllMethodsExceptMove): void {\n    const propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, store);\n  }\n\n  // SORTABLE DOM HANDLING\n\n  onAdd(evt: MultiDragEvent): void {\n    const { list, setList, clone } = this.props;\n    /* eslint-disable-next-line */\n    const otherList = [...store.dragging!.props.list];\n    const customs = createCustoms(evt, otherList);\n    removeNodes(customs);\n    const newList = handleStateAdd(customs, list, evt, clone).map((item) => ({\n      ...item,\n      selected: false,\n    }));\n    setList(newList, this.sortable, store);\n  }\n\n  onRemove(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const mode = getMode(evt);\n    const customs = createCustoms(evt, list);\n    insertNodes(customs);\n\n    let newList = [...list];\n    // remove state if not in clone mode. otherwise, keep.\n    if (evt.pullMode !== \"clone\") newList = handleStateRemove(customs, newList);\n    // if clone, it doesn't really remove. instead it clones in place.\n    // @todo -\n    else {\n      // switch used to get the clone\n      let customClones = customs;\n      switch (mode) {\n        case \"multidrag\":\n          customClones = customs.map((item, index) => ({\n            ...item,\n            element: evt.clones[index],\n          }));\n          break;\n        case \"normal\":\n          customClones = customs.map((item) => ({\n            ...item,\n            element: evt.clone,\n          }));\n          break;\n        case \"swap\":\n        default: {\n          invariant(\n            true,\n            `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`\n          );\n        }\n      }\n      removeNodes(customClones);\n\n      // replace selected items with cloned items\n      customs.forEach((curr) => {\n        const index = curr.oldIndex;\n        /* eslint-disable-next-line */\n        const newItem = this.props.clone!(curr.item, evt);\n        newList.splice(index, 1, newItem);\n      });\n    }\n\n    // remove item.selected from list\n    newList = newList.map((item) => ({ ...item, selected: false }));\n    setList(newList, this.sortable, store);\n  }\n\n  onUpdate(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const customs = createCustoms(evt, list);\n    removeNodes(customs);\n    insertNodes(customs);\n    const newList = handleStateChanges(customs, list);\n    return setList(newList, this.sortable, store);\n  }\n\n  onStart(): void {\n    store.dragging = this;\n  }\n\n  onEnd(): void {\n    store.dragging = null;\n  }\n\n  onChoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      if (index === evt.oldIndex) {\n        return {\n          ...item,\n          chosen: true,\n        };\n      }\n      return item;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onUnchoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      if (index === evt.oldIndex) {\n        return {\n          ...item,\n          chosen: false,\n        };\n      }\n      return item;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onSpill(evt: SortableEvent): void {\n    const { removeOnSpill, revertOnSpill } = this.props;\n    if (removeOnSpill && !revertOnSpill) removeNode(evt.item);\n  }\n\n  onSelect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item) => ({ ...item, selected: false }));\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) {\n        console.log(\n          `\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`\n        );\n        console.log(evt);\n        return;\n      }\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onDeselect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item) => ({ ...item, selected: false }));\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n}\n\n// everything below this point can be removed\n// once @types has been merged. PR submited\ninterface MultiIndices {\n  multiDragElement: HTMLElement;\n  index: number;\n}\n\nexport interface MultiDragEvent extends SortableEvent {\n  // @todo - add this to @types\n  clones: HTMLElement[];\n  oldIndicies: MultiIndices[];\n  newIndicies: MultiIndices[];\n  swapItem: HTMLElement | null;\n}\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","function userAgent(pattern) {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    return !!(/*@__PURE__*/ navigator.userAgent.match(pattern));\n  }\n}\n\nexport const IE11OrLess = userAgent(\n  /(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i\n);\nexport const Edge = userAgent(/Edge/i);\nexport const FireFox = userAgent(/firefox/i);\nexport const Safari =\n  userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nexport const IOS = userAgent(/iP(ad|od|hone)/i);\nexport const ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n","import { IE11OrLess } from \"./browser-info\";\nimport Sortable from \"../../sortable/src/Sortable\";\n\nconst captureMode = {\n  capture: false,\n  passive: false,\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(/**HTMLElement*/ el, /**String*/ selector) {\n  if (!selector) return;\n\n  selector[0] === \">\" && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType\n    ? el.host\n    : el.parentNode;\n}\n\nfunction closest(\n  /**HTMLElement*/ el,\n  /**String*/ selector,\n  /**HTMLElement*/ ctx,\n  includeCTX\n) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (\n        (selector != null &&\n          (selector[0] === \">\"\n            ? el.parentNode === ctx && matches(el, selector)\n            : matches(el, selector))) ||\n        (includeCTX && el === ctx)\n      ) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while ((el = getParentOrHost(el)));\n  }\n\n  return null;\n}\n\nconst R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? \"add\" : \"remove\"](name);\n    } else {\n      let className = (\" \" + el.className + \" \")\n        .replace(R_SPACE, \" \")\n        .replace(\" \" + name + \" \", \" \");\n      el.className = (className + (state ? \" \" + name : \"\")).replace(\n        R_SPACE,\n        \" \"\n      );\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  let style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, \"\");\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf(\"webkit\") === -1) {\n        prop = \"-webkit-\" + prop;\n      }\n\n      style[prop] = val + (typeof val === \"string\" ? \"\" : \"px\");\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  let appliedTransforms = \"\";\n  if (typeof el === \"string\") {\n    appliedTransforms = el;\n  } else {\n    do {\n      //@ts-ignore\n      let transform = css(el, \"transform\");\n\n      if (transform && transform !== \"none\") {\n        appliedTransforms = transform + \" \" + appliedTransforms;\n      }\n      /* jshint boss:true */\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  const matrixFn =\n    window.DOMMatrix ||\n    window.WebKitCSSMatrix ||\n    //@ts-ignore\n    window.CSSMatrix ||\n    //@ts-ignore\n    window.MSCSSMatrix;\n  /*jshint -W056 */\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    let list = ctx.getElementsByTagName(tagName),\n      i = 0,\n      n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  let scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\nfunction getRect(\n  el,\n  relativeToContainingBlock,\n  relativeToNonStaticParent,\n  undoScale,\n  container\n) {\n  if (!el.getBoundingClientRect && el !== window) return;\n\n  let elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if (\n    (relativeToContainingBlock || relativeToNonStaticParent) &&\n    el !== window\n  ) {\n    // Adjust for translate()\n    container = container || el.parentNode;\n\n    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n    if (!IE11OrLess) {\n      do {\n        if (\n          container &&\n          container.getBoundingClientRect &&\n          //@ts-ignore\n          (css(container, \"transform\") !== \"none\" ||\n            (relativeToNonStaticParent &&\n              //@ts-ignore\n              css(container, \"position\") !== \"static\"))\n        ) {\n          let containerRect = container.getBoundingClientRect();\n\n          // Set relative to edges of padding box of container\n          top -=\n            //@ts-ignore\n            containerRect.top + parseInt(css(container, \"border-top-width\"));\n          left -=\n            //@ts-ignore\n            containerRect.left + parseInt(css(container, \"border-left-width\"));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n\n          break;\n        }\n        /* jshint boss:true */\n      } while ((container = container.parentNode));\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    //@ts-ignore\n    let elMatrix = matrix(container || el),\n      scaleX = elMatrix && elMatrix.a,\n      scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n\n      width /= scaleX;\n      height /= scaleY;\n\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height,\n  };\n}\n\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\nfunction isScrolledPast(el, elSide, parentSide) {\n  let parent = getParentAutoScrollElement(el, true),\n    //@ts-ignore\n    elSideVal = getRect(el)[elSide];\n\n  /* jshint boss:true */\n  while (parent) {\n    //@ts-ignore\n    let parentSideVal = getRect(parent)[parentSide],\n      visible;\n\n    if (parentSide === \"top\" || parentSide === \"left\") {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n\n    if (parent === getWindowScrollingElement()) break;\n\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\nfunction getChild(el, childNum, options) {\n  let currentChild = 0,\n    i = 0,\n    children = el.children;\n\n  while (i < children.length) {\n    if (\n      children[i].style.display !== \"none\" &&\n      //@ts-ignore\n      children[i] !== Sortable.ghost &&\n      //@ts-ignore\n      children[i] !== Sortable.dragged &&\n      closest(children[i], options.draggable, el, false)\n    ) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n      currentChild++;\n    }\n\n    i++;\n  }\n  return null;\n}\n\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\nfunction lastChild(el, selector) {\n  let last = el.lastElementChild;\n\n  while (\n    last &&\n    //@ts-ignore\n    (last === Sortable.ghost ||\n      //@ts-ignore\n      css(last, \"display\") === \"none\" ||\n      (selector && !matches(last, selector)))\n  ) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\nfunction index(el, selector) {\n  let index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n\n  /* jshint boss:true */\n  while ((el = el.previousElementSibling)) {\n    if (\n      el.nodeName.toUpperCase() !== \"TEMPLATE\" &&\n      //@ts-ignore\n      el !== Sortable.clone &&\n      (!selector || matches(el, selector))\n    ) {\n      index++;\n    }\n  }\n\n  return index;\n}\n\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\nfunction getRelativeScrollOffset(el) {\n  let offsetLeft = 0,\n    offsetTop = 0,\n    winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      //@ts-ignore\n      let elMatrix = matrix(el),\n        scaleX = elMatrix.a,\n        scaleY = elMatrix.d;\n\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\nfunction indexOfObject(arr, obj) {\n  for (let i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n\n  let elem = el;\n  let gotSelf = false;\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (\n      elem.clientWidth < elem.scrollWidth ||\n      elem.clientHeight < elem.scrollHeight\n    ) {\n      //@ts-ignore\n      let elemCSS = css(elem);\n      if (\n        (elem.clientWidth < elem.scrollWidth &&\n          (elemCSS.overflowX == \"auto\" || elemCSS.overflowX == \"scroll\")) ||\n        (elem.clientHeight < elem.scrollHeight &&\n          (elemCSS.overflowY == \"auto\" || elemCSS.overflowY == \"scroll\"))\n      ) {\n        if (!elem.getBoundingClientRect || elem === document.body)\n          return getWindowScrollingElement();\n\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n  } while ((elem = elem.parentNode));\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (let key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return (\n    Math.round(rect1.top) === Math.round(rect2.top) &&\n    Math.round(rect1.left) === Math.round(rect2.left) &&\n    Math.round(rect1.height) === Math.round(rect2.height) &&\n    Math.round(rect1.width) === Math.round(rect2.width)\n  );\n}\n\nlet _throttleTimeout;\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      let args = arguments,\n        _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  //@ts-ignore\n  let Polymer = window.Polymer;\n  //@ts-ignore\n  let $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, \"position\", \"absolute\");\n  css(el, \"top\", rect.top);\n  css(el, \"left\", rect.left);\n  css(el, \"width\", rect.width);\n  css(el, \"height\", rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, \"position\", \"\");\n  css(el, \"top\", \"\");\n  css(el, \"left\", \"\");\n  css(el, \"width\", \"\");\n  css(el, \"height\", \"\");\n}\n\nconst expando = \"Sortable\" + new Date().getTime();\n\nexport {\n  on,\n  off,\n  matches,\n  getParentOrHost,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  indexOfObject,\n  getParentAutoScrollElement,\n  extend,\n  isRectEqual,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  clone,\n  setRect,\n  unsetRect,\n  expando,\n};\n","let plugins = [];\n\nconst defaults = {\n  initializeByDefault: true,\n};\n\nconst pluginManager = {\n  mount(plugin) {\n    // Set default static properties\n    for (let option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n    plugins.push(plugin);\n  },\n  pluginEvent(eventName, sortable, evt) {\n    this.eventCanceled = false;\n    evt.cancel = () => {\n      this.eventCanceled = true;\n    };\n    const eventNameGlobal = eventName + \"Global\";\n    plugins.forEach((plugin) => {\n      if (!sortable[plugin.pluginName]) return;\n      // Fire global events if it exists in this sortable\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal]({ sortable, ...evt });\n      }\n\n      // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n      if (\n        sortable.options[plugin.pluginName] &&\n        sortable[plugin.pluginName][eventName]\n      ) {\n        sortable[plugin.pluginName][eventName]({ sortable, ...evt });\n      }\n    });\n  },\n  initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach((plugin) => {\n      const pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n\n      let initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized;\n\n      // Add default options from plugin\n      Object.assign(defaults, initialized.defaults);\n    });\n\n    for (let option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      let modified = this.modifyOption(\n        sortable,\n        option,\n        sortable.options[option]\n      );\n      if (typeof modified !== \"undefined\") {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties(name, sortable) {\n    let eventProperties = {};\n    plugins.forEach((plugin) => {\n      if (typeof plugin.eventProperties !== \"function\") return;\n      Object.assign(\n        eventProperties,\n        plugin.eventProperties.call(sortable[plugin.pluginName], name)\n      );\n    });\n\n    return eventProperties;\n  },\n  modifyOption(sortable, name, value) {\n    let modifiedValue;\n    plugins.forEach((plugin) => {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return;\n\n      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n      if (\n        plugin.optionListeners &&\n        typeof plugin.optionListeners[name] === \"function\"\n      ) {\n        modifiedValue = plugin.optionListeners[name].call(\n          sortable[plugin.pluginName],\n          value\n        );\n      }\n    });\n\n    return modifiedValue;\n  },\n};\n\nexport default pluginManager;\n","import { expando, IE11OrLess, Edge } from \"../../utils/src\";\nimport PluginManager from \"./PluginManager\";\n\nexport default function dispatchEvent({\n  sortable,\n  rootEl,\n  name,\n  targetEl,\n  cloneEl,\n  toEl,\n  fromEl,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  originalEvent,\n  putSortable,\n  extraEventProperties,\n}) {\n  sortable = sortable || (rootEl && rootEl[expando]);\n  if (!sortable) return;\n\n  let evt,\n    options = sortable.options,\n    onName = \"on\" + name.charAt(0).toUpperCase() + name.substr(1);\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  let allEventProperties = {\n    ...extraEventProperties,\n    ...PluginManager.getEventProperties(name, sortable),\n  };\n  for (let option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n","import { version } from \"../package.json\";\nimport AnimationStateManager from \"./Animation\";\nimport PluginManager from \"./PluginManager\";\nimport dispatchEvent from \"./EventDispatcher\";\n/**\n * @todo import as namespace: import * as utils from \"../../utils/src\"\n */\nimport {\n  on,\n  off,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  extend,\n  throttle,\n  scrollBy,\n  clone,\n  expando,\n  IE11OrLess,\n  Edge,\n  FireFox,\n  Safari,\n  IOS,\n  ChromeForAndroid,\n} from \"../../utils/src\";\n\nlet pluginEvent = function (\n  eventName,\n  sortable,\n  //@ts-ignore\n  { evt: originalEvent, ...data } = {}\n) {\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, {\n    dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    dragStarted: moved,\n    putSortable,\n    //@ts-ignore\n    activeSortable: Sortable.active,\n    originalEvent,\n\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n\n    cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown() {\n      cloneHidden = false;\n    },\n\n    dispatchSortableEvent(name) {\n      _dispatchEvent({ sortable, name, originalEvent });\n    },\n\n    ...data,\n  });\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent({\n    putSortable,\n    cloneEl,\n    targetEl: dragEl,\n    rootEl,\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n    ...info,\n  });\n}\n\nlet dragEl,\n  parentEl,\n  ghostEl,\n  rootEl,\n  nextEl,\n  lastDownEl,\n  cloneEl,\n  cloneHidden,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  activeGroup,\n  putSortable,\n  awaitingDragStarted = false,\n  ignoreNextClick = false,\n  sortables = [],\n  tapEvt,\n  touchEvt,\n  lastDx,\n  lastDy,\n  tapDistanceLeft,\n  tapDistanceTop,\n  moved,\n  lastTarget,\n  lastDirection,\n  pastFirstInvertThresh = false,\n  isCircumstantialInvert = false,\n  targetMoveDistance,\n  // For positioning ghost absolutely\n  ghostRelativeParent,\n  ghostRelativeParentInitialScroll = [], // (left, top)\n  _silent = false,\n  savedInputChecked = [];\n\n/** @const */\nconst documentExists = typeof document !== \"undefined\",\n  PositionGhostAbsolutely = IOS,\n  CSSFloatProperty = Edge || IE11OrLess ? \"cssFloat\" : \"float\",\n  // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable =\n    documentExists &&\n    !ChromeForAndroid &&\n    !IOS &&\n    \"draggable\" in document.createElement(\"div\"),\n  supportCssPointerEvents = (function () {\n    if (!documentExists) return;\n    // false when <= IE11\n    if (IE11OrLess) {\n      return false;\n    }\n    let el = document.createElement(\"x\");\n    el.style.cssText = \"pointer-events:auto\";\n    return el.style.pointerEvents === \"auto\";\n  })(),\n  _detectDirection = function (el, options) {\n    //@ts-ignore\n    let elCSS = css(el),\n      elWidth =\n        parseInt(elCSS.width) -\n        parseInt(elCSS.paddingLeft) -\n        parseInt(elCSS.paddingRight) -\n        parseInt(elCSS.borderLeftWidth) -\n        parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      //@ts-ignore\n      firstChildCSS = child1 && css(child1),\n      //@ts-ignore\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth =\n        firstChildCSS &&\n        parseInt(firstChildCSS.marginLeft) +\n          parseInt(firstChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child1).width,\n      secondChildWidth =\n        secondChildCSS &&\n        parseInt(secondChildCSS.marginLeft) +\n          parseInt(secondChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child2).width;\n\n    if (elCSS.display === \"flex\") {\n      return elCSS.flexDirection === \"column\" ||\n        elCSS.flexDirection === \"column-reverse\"\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (elCSS.display === \"grid\") {\n      return elCSS.gridTemplateColumns.split(\" \").length <= 1\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (child1 && firstChildCSS.float && firstChildCSS.float !== \"none\") {\n      let touchingSideChild2 =\n        firstChildCSS.float === \"left\" ? \"left\" : \"right\";\n\n      return child2 &&\n        (secondChildCSS.clear === \"both\" ||\n          secondChildCSS.clear === touchingSideChild2)\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    return child1 &&\n      (firstChildCSS.display === \"block\" ||\n        firstChildCSS.display === \"flex\" ||\n        firstChildCSS.display === \"table\" ||\n        firstChildCSS.display === \"grid\" ||\n        (firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === \"none\") ||\n        (child2 &&\n          elCSS[CSSFloatProperty] === \"none\" &&\n          firstChildWidth + secondChildWidth > elWidth))\n      ? \"vertical\"\n      : \"horizontal\";\n  },\n  _dragElInRowColumn = function (dragRect, targetRect, vertical) {\n    let dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n\n    return (\n      dragElS1Opp === targetS1Opp ||\n      dragElS2Opp === targetS2Opp ||\n      dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2\n    );\n  },\n  /**\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n   * @param  {Number} x      X position\n   * @param  {Number} y      Y position\n   * @return {HTMLElement}   Element of the first found nearest Sortable\n   */\n  _detectNearestEmptySortable = function (x, y) {\n    let ret;\n    sortables.some((sortable) => {\n      //@ts-ignore\n      if (lastChild(sortable)) return;\n\n      //@ts-ignore\n      let rect = getRect(sortable),\n        threshold = sortable[expando].options.emptyInsertThreshold,\n        insideHorizontally =\n          x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically =\n          y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n      if (threshold && insideHorizontally && insideVertically) {\n        return (ret = sortable);\n      }\n    });\n    return ret;\n  },\n  _prepareGroup = function (options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        let sameGroup =\n          to.options.group.name &&\n          from.options.group.name &&\n          to.options.group.name === from.options.group.name;\n\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === \"clone\") {\n          return value;\n        } else if (typeof value === \"function\") {\n          return toFn(value(to, from, dragEl, evt), pull)(\n            to,\n            from,\n            dragEl,\n            evt\n          );\n        } else {\n          let otherGroup = (pull ? to : from).options.group.name;\n\n          return (\n            value === true ||\n            (typeof value === \"string\" && value === otherGroup) ||\n            (value.join && value.indexOf(otherGroup) > -1)\n          );\n        }\n      };\n    }\n\n    let group = {};\n    let originalGroup = options.group;\n\n    if (!originalGroup || typeof originalGroup != \"object\") {\n      originalGroup = { name: originalGroup };\n    }\n\n    //@ts-ignore\n    group.name = originalGroup.name;\n    //@ts-ignore\n    group.checkPull = toFn(originalGroup.pull, true);\n    //@ts-ignore\n    group.checkPut = toFn(originalGroup.put);\n    //@ts-ignore\n    group.revertClone = originalGroup.revertClone;\n\n    options.group = group;\n  },\n  _hideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"none\");\n    }\n  },\n  _unhideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"\");\n    }\n  };\n\n// #1184 fix - Prevent click event on fallback if dragged but item not changed position\nif (documentExists) {\n  document.addEventListener(\n    \"click\",\n    function (evt) {\n      if (ignoreNextClick) {\n        evt.preventDefault();\n        evt.stopPropagation && evt.stopPropagation();\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n        ignoreNextClick = false;\n        return false;\n      }\n    },\n    true\n  );\n}\n\nlet nearestEmptyInsertDetectEvent = function (evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n    let nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      let event = {};\n      for (let i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n      //@ts-ignore\n      event.target = event.rootEl = nearest;\n      //@ts-ignore\n      event.preventDefault = void 0;\n      //@ts-ignore\n      event.stopPropagation = void 0;\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nlet _checkOutsideTargetEl = function (evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw `Sortable: \\`el\\` must be an HTMLElement, not ${{}.toString.call(\n      el\n    )}`;\n  }\n\n  this.el = el; // root element\n  this.options = options = Object.assign({}, options);\n\n  // Export instance\n  el[expando] = this;\n\n  let defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? \">li\" : \">*\",\n    swapThreshold: 1, // percentage; 0 <= x <= 1\n    invertSwap: false, // invert always\n    invertedSwapThreshold: null, // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function () {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: \"sortable-ghost\",\n    chosenClass: \"sortable-chosen\",\n    dragClass: \"sortable-drag\",\n    ignore: \"a, img\",\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function (dataTransfer, dragEl) {\n      dataTransfer.setData(\"Text\", dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: \"data-id\",\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold:\n      (Number.parseInt ? Number : window).parseInt(\n        //@ts-ignore\n        window.devicePixelRatio,\n        10\n      ) || 1,\n    forceFallback: false,\n    fallbackClass: \"sortable-fallback\",\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: { x: 0, y: 0 },\n    supportPointer:\n      //@ts-ignore\n      Sortable.supportPointer !== false && \"PointerEvent\" in window,\n    emptyInsertThreshold: 5,\n  };\n\n  //@ts-ignore\n  PluginManager.initializePlugins(this, el, defaults);\n\n  // Set default options\n  for (let name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options);\n\n  // Bind all private methods\n  for (let fn in this) {\n    if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n      this[fn] = this[fn].bind(this);\n    }\n  }\n\n  // Setup drag mode\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  }\n\n  // Bind events\n  if (options.supportPointer) {\n    on(el, \"pointerdown\", this._onTapStart);\n  } else {\n    on(el, \"mousedown\", this._onTapStart);\n    on(el, \"touchstart\", this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, \"dragover\", this);\n    on(el, \"dragenter\", this);\n  }\n\n  sortables.push(this.el);\n\n  // Restore sorting\n  options.store &&\n    options.store.get &&\n    this.sort(options.store.get(this) || []);\n\n  // Add animation state manager\n  Object.assign(this, AnimationStateManager());\n}\n\nSortable.prototype = /** @lends Sortable.prototype */ {\n  constructor: Sortable,\n\n  _isOutsideThisEl: function (target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n\n  _getDirection: function (evt, target) {\n    return typeof this.options.direction === \"function\"\n      ? this.options.direction.call(this, evt, target, dragEl)\n      : this.options.direction;\n  },\n\n  _onTapStart: function (/** Event|TouchEvent */ evt) {\n    if (!evt.cancelable) return;\n    let _this = this,\n      el = this.el,\n      options = this.options,\n      preventOnFilter = options.preventOnFilter,\n      type = evt.type,\n      touch =\n        (evt.touches && evt.touches[0]) ||\n        (evt.pointerType && evt.pointerType === \"touch\" && evt),\n      target = (touch || evt).target,\n      originalTarget =\n        (evt.target.shadowRoot &&\n          ((evt.path && evt.path[0]) ||\n            (evt.composedPath && evt.composedPath()[0]))) ||\n        target,\n      filter = options.filter;\n\n    _saveInputCheckedState(el);\n\n    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n    if (dragEl) {\n      return;\n    }\n\n    if (\n      (/mousedown|pointerdown/.test(type) && evt.button !== 0) ||\n      options.disabled\n    ) {\n      return; // only left button and enabled\n    }\n\n    // cancel dnd if original target is content editable\n    if (originalTarget.isContentEditable) {\n      return;\n    }\n\n    // Safari ignores further event handling after mousedown\n    if (\n      !this.nativeDraggable &&\n      Safari &&\n      target &&\n      target.tagName.toUpperCase() === \"SELECT\"\n    ) {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    }\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable);\n\n    // Check filter\n    if (typeof filter === \"function\") {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: \"filter\",\n          targetEl: target,\n          toEl: el,\n          fromEl: el,\n        });\n        pluginEvent(\"filter\", _this, { evt });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(\",\").some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: \"filter\",\n            targetEl: target,\n            fromEl: el,\n            toEl: el,\n          });\n          pluginEvent(\"filter\", _this, { evt });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    }\n\n    // Prepare `dragstart`\n    this._prepareDragStart(evt, touch, target);\n  },\n\n  _prepareDragStart: function (\n    /** Event */ evt,\n    /** Touch */ touch,\n    /** HTMLElement */ target\n  ) {\n    let _this = this,\n      el = _this.el,\n      options = _this.options,\n      ownerDocument = el.ownerDocument,\n      dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      //@ts-ignore\n      let dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n\n      //@ts-ignore\n      Sortable.dragged = dragEl;\n\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY,\n      };\n\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n\n      dragEl.style[\"will-change\"] = \"all\";\n\n      dragStartFn = function () {\n        pluginEvent(\"delayEnded\", _this, { evt });\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n          return;\n        }\n        // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        }\n\n        // Bind the events: dragstart/dragend\n        _this._triggerDragStart(evt, touch);\n\n        // Drag start event\n        _dispatchEvent({\n          sortable: _this,\n          name: \"choose\",\n          originalEvent: evt,\n        });\n\n        // Chosen item\n        toggleClass(dragEl, options.chosenClass, true);\n      };\n\n      // Disable \"draggable\"\n      options.ignore.split(\",\").forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n\n      on(ownerDocument, \"dragover\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"mousemove\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"touchmove\", nearestEmptyInsertDetectEvent);\n\n      on(ownerDocument, \"mouseup\", _this._onDrop);\n      on(ownerDocument, \"touchend\", _this._onDrop);\n      on(ownerDocument, \"touchcancel\", _this._onDrop);\n\n      // Make dragEl draggable (must be before delay for FireFox)\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent(\"delayStart\", this, { evt });\n\n      // Delay is impossible for native DnD in Edge or IE\n      if (\n        options.delay &&\n        (!options.delayOnTouchOnly || touch) &&\n        (!this.nativeDraggable || !(Edge || IE11OrLess))\n      ) {\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n          return;\n        }\n        // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n        on(ownerDocument, \"mouseup\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchend\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchcancel\", _this._disableDelayedDrag);\n        on(ownerDocument, \"mousemove\", _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, \"touchmove\", _this._delayedDragTouchMoveHandler);\n        options.supportPointer &&\n          on(ownerDocument, \"pointermove\", _this._delayedDragTouchMoveHandler);\n\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n\n  _delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/ e) {\n    let touch = e.touches ? e.touches[0] : e;\n    if (\n      Math.max(\n        Math.abs(touch.clientX - this._lastX),\n        Math.abs(touch.clientY - this._lastY)\n      ) >=\n      Math.floor(\n        this.options.touchStartThreshold /\n          ((this.nativeDraggable && window.devicePixelRatio) || 1)\n      )\n    ) {\n      this._disableDelayedDrag();\n    }\n  },\n\n  _disableDelayedDrag: function () {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n\n  _disableDelayedDragEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, \"mouseup\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchend\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchcancel\", this._disableDelayedDrag);\n    off(ownerDocument, \"mousemove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"touchmove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"pointermove\", this._delayedDragTouchMoveHandler);\n  },\n\n  _triggerDragStart: function (/** Event */ evt, /** Touch */ touch) {\n    touch = touch || (evt.pointerType == \"touch\" && evt);\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, \"pointermove\", this._onTouchMove);\n      } else if (touch) {\n        on(document, \"touchmove\", this._onTouchMove);\n      } else {\n        on(document, \"mousemove\", this._onTouchMove);\n      }\n    } else {\n      on(dragEl, \"dragend\", this);\n      on(rootEl, \"dragstart\", this._onDragStart);\n    }\n\n    try {\n      //@ts-ignore\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          //@ts-ignore\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n\n  _dragStarted: function (fallback, evt) {\n    let _this = this;\n    awaitingDragStarted = false;\n    if (rootEl && dragEl) {\n      pluginEvent(\"dragStarted\", this, { evt });\n\n      if (this.nativeDraggable) {\n        on(document, \"dragover\", _checkOutsideTargetEl);\n      }\n      let options = this.options;\n\n      // Apply effect\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n\n      //@ts-ignore\n      Sortable.active = this;\n\n      fallback && this._appendGhost();\n\n      // Drag start event\n      _dispatchEvent({\n        sortable: this,\n        name: \"start\",\n        originalEvent: evt,\n      });\n    } else {\n      this._nulling();\n    }\n  },\n\n  _emulateDragOver: function () {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      let target = document.elementFromPoint(\n        touchEvt.clientX,\n        touchEvt.clientY\n      );\n      let parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(\n          touchEvt.clientX,\n          touchEvt.clientY\n        );\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            let inserted;\n\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent,\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        } while (\n          /* jshint boss:true */\n          //@ts-ignore\n          (parent = parent.parentNode)\n        );\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n\n  _onTouchMove: function (/**TouchEvent*/ evt) {\n    if (tapEvt) {\n      let options = this.options,\n        fallbackTolerance = options.fallbackTolerance,\n        fallbackOffset = options.fallbackOffset,\n        touch = evt.touches ? evt.touches[0] : evt,\n        ghostMatrix = ghostEl && matrix(ghostEl, true),\n        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n        relativeScrollOffset =\n          PositionGhostAbsolutely &&\n          ghostRelativeParent &&\n          getRelativeScrollOffset(ghostRelativeParent),\n        dx =\n          (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]\n            : 0) /\n            (scaleX || 1),\n        dy =\n          (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]\n            : 0) /\n            (scaleY || 1);\n\n      // only set the status to dragging, when we are actually dragging\n      //@ts-ignore\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (\n          fallbackTolerance &&\n          Math.max(\n            Math.abs(touch.clientX - this._lastX),\n            Math.abs(touch.clientY - this._lastY)\n          ) < fallbackTolerance\n        ) {\n          return;\n        }\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy,\n          };\n        }\n\n        let cssMatrix = `matrix(${ghostMatrix.a},${ghostMatrix.b},${ghostMatrix.c},${ghostMatrix.d},${ghostMatrix.e},${ghostMatrix.f})`;\n\n        css(ghostEl, \"webkitTransform\", cssMatrix);\n        css(ghostEl, \"mozTransform\", cssMatrix);\n        css(ghostEl, \"msTransform\", cssMatrix);\n        css(ghostEl, \"transform\", cssMatrix);\n\n        lastDx = dx;\n        lastDy = dy;\n\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n\n  _appendGhost: function () {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      let container = this.options.fallbackOnBody ? document.body : rootEl,\n        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n        options = this.options;\n\n      // Position absolutely\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (\n          //@ts-ignore\n          css(ghostRelativeParent, \"position\") === \"static\" &&\n          //@ts-ignore\n          css(ghostRelativeParent, \"transform\") === \"none\" &&\n          ghostRelativeParent !== document\n        ) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (\n          ghostRelativeParent !== document.body &&\n          ghostRelativeParent !== document.documentElement\n        ) {\n          if (ghostRelativeParent === document)\n            ghostRelativeParent = getWindowScrollingElement();\n\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(\n          ghostRelativeParent\n        );\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n\n      css(ghostEl, \"transition\", \"\");\n      css(ghostEl, \"transform\", \"\");\n\n      css(ghostEl, \"box-sizing\", \"border-box\");\n      css(ghostEl, \"margin\", 0);\n      css(ghostEl, \"top\", rect.top);\n      css(ghostEl, \"left\", rect.left);\n      css(ghostEl, \"width\", rect.width);\n      css(ghostEl, \"height\", rect.height);\n      css(ghostEl, \"opacity\", \"0.8\");\n      css(ghostEl, \"position\", PositionGhostAbsolutely ? \"absolute\" : \"fixed\");\n      css(ghostEl, \"zIndex\", \"100000\");\n      css(ghostEl, \"pointerEvents\", \"none\");\n\n      //@ts-ignore\n      Sortable.ghost = ghostEl;\n\n      container.appendChild(ghostEl);\n\n      // Set transform-origin\n      css(\n        ghostEl,\n        \"transform-origin\",\n        (tapDistanceLeft / parseInt(ghostEl.style.width)) * 100 +\n          \"% \" +\n          (tapDistanceTop / parseInt(ghostEl.style.height)) * 100 +\n          \"%\"\n      );\n    }\n  },\n\n  _onDragStart: function (/**Event*/ evt, /**boolean*/ fallback) {\n    let _this = this;\n    let dataTransfer = evt.dataTransfer;\n    let options = _this.options;\n\n    pluginEvent(\"dragStart\", this, { evt });\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n      return;\n    }\n\n    pluginEvent(\"setupClone\", this);\n    //@ts-ignore\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n\n      cloneEl.draggable = false;\n      cloneEl.style[\"will-change\"] = \"\";\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      //@ts-ignore\n      Sortable.clone = cloneEl;\n    }\n\n    // #1143: IFrame support workaround\n    _this.cloneId = _nextTick(function () {\n      pluginEvent(\"clone\", _this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: \"clone\",\n      });\n    });\n\n    !fallback && toggleClass(dragEl, options.dragClass, true);\n\n    // Set proper drop events\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, \"mouseup\", _this._onDrop);\n      off(document, \"touchend\", _this._onDrop);\n      off(document, \"touchcancel\", _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = \"move\";\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, \"drop\", _this);\n\n      // #1276 fix:\n      css(dragEl, \"transform\", \"translateZ(0)\");\n    }\n\n    awaitingDragStarted = true;\n\n    _this._dragStartId = _nextTick(\n      _this._dragStarted.bind(_this, fallback, evt)\n    );\n    on(document, \"selectstart\", _this);\n\n    moved = true;\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"none\");\n    }\n  },\n\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function (/**Event*/ evt) {\n    let el = this.el,\n      target = evt.target,\n      dragRect,\n      targetRect,\n      revert,\n      options = this.options,\n      group = options.group,\n      //@ts-ignore\n      activeSortable = Sortable.active,\n      isOwner = activeGroup === group,\n      canSort = options.sort,\n      fromSortable = putSortable || activeSortable,\n      vertical,\n      _this = this,\n      completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, {\n        evt,\n        isOwner,\n        axis: vertical ? \"vertical\" : \"horizontal\",\n        revert,\n        dragRect,\n        targetRect,\n        canSort,\n        fromSortable,\n        target,\n        completed,\n        onMove(target, after) {\n          return onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            //@ts-ignore\n            getRect(target),\n            evt,\n            after\n          );\n        },\n        changed,\n        ...extra,\n      });\n    }\n\n    // Capture animation state\n    function capture() {\n      //@ts-ignore\n      dragOverEvent(\"dragOverAnimationCapture\");\n\n      _this.captureAnimationState();\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    }\n\n    // Return invocation when dragEl is inserted (or completed)\n    function completed(insertion) {\n      dragOverEvent(\"dragOverCompleted\", { insertion });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : activeSortable.options.ghostClass,\n            false\n          );\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        //@ts-ignore\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n          //@ts-ignore\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        }\n\n        // Animation\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n        _this.animateAll(function () {\n          //@ts-ignore\n          dragOverEvent(\"dragOverAnimationComplete\");\n          _this._ignoreWhileAnimating = null;\n        });\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      }\n\n      // Null lastTarget if it is not inside a previously swapped element\n      if (\n        (target === dragEl && !dragEl.animated) ||\n        (target === el && !target.animated)\n      ) {\n        lastTarget = null;\n      }\n\n      // no bubbling and not fallback\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n\n        // Do not detect for empty insert if already inserted\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n\n      return (completedFired = true);\n    }\n\n    // Call when dragEl has been inserted\n    function changed() {\n      //@ts-ignore\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      _dispatchEvent({\n        sortable: _this,\n        name: \"change\",\n        toEl: el,\n        newIndex,\n        newDraggableIndex,\n        originalEvent: evt,\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n\n    //@ts-ignore\n    dragOverEvent(\"dragOver\");\n    //@ts-ignore\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (\n      dragEl.contains(evt.target) ||\n      (target.animated && target.animatingX && target.animatingY) ||\n      _this._ignoreWhileAnimating === target\n    ) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (\n      activeSortable &&\n      !options.disabled &&\n      (isOwner\n        ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n        : putSortable === this ||\n          ((this.lastPutMode = activeGroup.checkPull(\n            this,\n            activeSortable,\n            dragEl,\n            evt\n          )) &&\n            group.checkPut(this, activeSortable, dragEl, evt)))\n    ) {\n      vertical = this._getDirection(evt, target) === \"vertical\";\n\n      //@ts-ignore\n      dragRect = getRect(dragEl);\n\n      //@ts-ignore\n      dragOverEvent(\"dragOverValid\");\n      //@ts-ignore\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n        capture();\n\n        this._hideClone();\n\n        //@ts-ignore\n        dragOverEvent(\"revert\");\n\n        //@ts-ignore\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      let elLastChild = lastChild(el, options.draggable);\n\n      if (\n        !elLastChild ||\n        (_ghostIsLast(evt, vertical, this) && !elLastChild.animated)\n      ) {\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        }\n\n        // assign target only if condition is true\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          //@ts-ignore\n          targetRect = getRect(target);\n        }\n\n        if (\n          onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            targetRect,\n            evt,\n            !!target\n          ) !== false\n        ) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        //@ts-ignore\n        targetRect = getRect(target);\n        let direction = 0,\n          targetBeforeFirstSwap,\n          differentLevel = dragEl.parentNode !== el,\n          differentRowCol = !_dragElInRowColumn(\n            (dragEl.animated && dragEl.toRect) || dragRect,\n            (target.animated && target.toRect) || targetRect,\n            vertical\n          ),\n          side1 = vertical ? \"top\" : \"left\",\n          scrolledPastTop =\n            isScrolledPast(target, \"top\", \"top\") ||\n            isScrolledPast(dragEl, \"top\", \"top\"),\n          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert =\n            (!differentRowCol && options.invertSwap) || differentLevel;\n        }\n\n        direction = _getSwapDirection(\n          evt,\n          target,\n          targetRect,\n          vertical,\n          differentRowCol ? 1 : options.swapThreshold,\n          options.invertedSwapThreshold == null\n            ? options.swapThreshold\n            : options.invertedSwapThreshold,\n          isCircumstantialInvert,\n          lastTarget === target\n        );\n\n        let sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          //@ts-ignore\n          let dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (\n            sibling &&\n            //@ts-ignore\n            (css(sibling, \"display\") === \"none\" || sibling === ghostEl)\n          );\n        }\n        // If dragEl is already beside target: Do not insert\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n\n        lastDirection = direction;\n\n        let nextSibling = target.nextElementSibling,\n          after = false;\n\n        after = direction === 1;\n\n        let moveVector = onMove(\n          rootEl,\n          el,\n          dragEl,\n          dragRect,\n          target,\n          targetRect,\n          evt,\n          after\n        );\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(\n              dragEl,\n              after ? nextSibling : target\n            );\n          }\n\n          // Undo chrome's scroll adjustment (has no effect on other browsers)\n          if (scrolledPastTop) {\n            scrollBy(\n              scrolledPastTop,\n              0,\n              scrollBefore - scrolledPastTop.scrollTop\n            );\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n\n          // must be done before animation\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(\n              //@ts-ignore\n              targetBeforeFirstSwap - getRect(target)[side1]\n            );\n          }\n          changed();\n\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n\n  _ignoreWhileAnimating: null,\n\n  _offMoveEvents: function () {\n    off(document, \"mousemove\", this._onTouchMove);\n    off(document, \"touchmove\", this._onTouchMove);\n    off(document, \"pointermove\", this._onTouchMove);\n    off(document, \"dragover\", nearestEmptyInsertDetectEvent);\n    off(document, \"mousemove\", nearestEmptyInsertDetectEvent);\n    off(document, \"touchmove\", nearestEmptyInsertDetectEvent);\n  },\n\n  _offUpEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n\n    off(ownerDocument, \"mouseup\", this._onDrop);\n    off(ownerDocument, \"touchend\", this._onDrop);\n    off(ownerDocument, \"pointerup\", this._onDrop);\n    off(ownerDocument, \"touchcancel\", this._onDrop);\n    off(document, \"selectstart\", this);\n  },\n\n  _onDrop: function (/**Event*/ evt) {\n    let el = this.el,\n      options = this.options;\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    pluginEvent(\"drop\", this, {\n      evt,\n    });\n\n    parentEl = dragEl && dragEl.parentNode;\n\n    // Get again after plugin event\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._nulling();\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n\n    clearInterval(this._loopId);\n\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n    _cancelNextTick(this._dragStartId);\n\n    // Unbind events\n    if (this.nativeDraggable) {\n      off(document, \"drop\", this);\n      off(el, \"dragstart\", this._onDragStart);\n    }\n    this._offMoveEvents();\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"\");\n    }\n\n    css(dragEl, \"transform\", \"\");\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        // Remove clone(s)\n        cloneEl &&\n          cloneEl.parentNode &&\n          cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, \"dragend\", this);\n        }\n\n        _disableDraggable(dragEl);\n        dragEl.style[\"will-change\"] = \"\";\n\n        // Remove classes\n        // ghostClass is added in dragStarted\n        if (moved && !awaitingDragStarted) {\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : this.options.ghostClass,\n            false\n          );\n        }\n        toggleClass(dragEl, this.options.chosenClass, false);\n\n        // Drag stop event\n        _dispatchEvent({\n          sortable: this,\n          name: \"unchoose\",\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt,\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"add\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            // Remove event\n            _dispatchEvent({\n              sortable: this,\n              name: \"remove\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n\n            // drag from one list and drop into another\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"sort\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: \"sort\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: \"update\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: \"sort\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n            }\n          }\n        }\n\n        //@ts-ignore\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: \"end\",\n            toEl: parentEl,\n            originalEvent: evt,\n          });\n\n          // Save sorting\n          this.save();\n        }\n      }\n    }\n    this._nulling();\n  },\n\n  _nulling: function () {\n    pluginEvent(\"nulling\", this);\n    //@ts-ignore\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n\n  handleEvent: function (/**Event*/ evt) {\n    switch (evt.type) {\n      case \"drop\":\n      case \"dragend\":\n        this._onDrop(evt);\n        break;\n\n      case \"dragenter\":\n      case \"dragover\":\n        if (dragEl) {\n          this._onDragOver(evt);\n          _globalDragOver(evt);\n        }\n        break;\n\n      case \"selectstart\":\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function () {\n    let order = [],\n      el,\n      children = this.el.children,\n      i = 0,\n      n = children.length,\n      options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function (order) {\n    let items = {},\n      rootEl = this.el;\n\n    this.toArray().forEach(function (id, i) {\n      let el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function () {\n    let store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function (el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function (name, value) {\n    let options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      let modifiedValue = PluginManager.modifyOption(this, name, value);\n      if (typeof modifiedValue !== \"undefined\") {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === \"group\") {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function () {\n    pluginEvent(\"destroy\", this);\n    let el = this.el;\n\n    el[expando] = null;\n\n    off(el, \"mousedown\", this._onTapStart);\n    off(el, \"touchstart\", this._onTapStart);\n    off(el, \"pointerdown\", this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, \"dragover\", this);\n      off(el, \"dragenter\", this);\n    }\n    // Remove draggable attributes\n    Array.prototype.forEach.call(el.querySelectorAll(\"[draggable]\"), function (\n      el\n    ) {\n      el.removeAttribute(\"draggable\");\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n\n    this.el = el = null;\n  },\n\n  _hideClone: function () {\n    if (!cloneHidden) {\n      pluginEvent(\"hideClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      css(cloneEl, \"display\", \"none\");\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n      cloneHidden = true;\n    }\n  },\n\n  _showClone: function (putSortable) {\n    if (putSortable.lastPutMode !== \"clone\") {\n      this._hideClone();\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent(\"showClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      // show clone at dragEl or original position\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, \"display\", \"\");\n      cloneHidden = false;\n    }\n  },\n};\n\nfunction _globalDragOver(/**Event*/ evt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = \"move\";\n  }\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction onMove(\n  fromEl,\n  toEl,\n  dragEl,\n  dragRect,\n  targetEl,\n  targetRect,\n  originalEvent,\n  willInsertAfter\n) {\n  let evt,\n    sortable = fromEl[expando],\n    onMoveFn = sortable.options.onMove,\n    retVal;\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(\"move\", {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(\"move\", true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  //@ts-ignore\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n\n  evt.originalEvent = originalEvent;\n\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  //@ts-ignore\n  let rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  const spacer = 10;\n\n  return vertical\n    ? evt.clientX > rect.right + spacer ||\n        (evt.clientX <= rect.right &&\n          evt.clientY > rect.bottom &&\n          evt.clientX >= rect.left)\n    : (evt.clientX > rect.right && evt.clientY > rect.top) ||\n        (evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer);\n}\n\nfunction _getSwapDirection(\n  evt,\n  target,\n  targetRect,\n  vertical,\n  swapThreshold,\n  invertedSwapThreshold,\n  invertSwap,\n  isLastTarget\n) {\n  let mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n    targetLength = vertical ? targetRect.height : targetRect.width,\n    targetS1 = vertical ? targetRect.top : targetRect.left,\n    targetS2 = vertical ? targetRect.bottom : targetRect.right,\n    invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (\n        !pastFirstInvertThresh &&\n        (lastDirection === 1\n          ? mouseOnAxis > targetS1 + (targetLength * invertedSwapThreshold) / 2\n          : mouseOnAxis < targetS2 - (targetLength * invertedSwapThreshold) / 2)\n      ) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (\n          lastDirection === 1\n            ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n            : mouseOnAxis > targetS2 - targetMoveDistance\n        ) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (\n        mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold)) / 2 &&\n        mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold)) / 2\n      ) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (\n      mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold) / 2 ||\n      mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold) / 2\n    ) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\nfunction _getInsertDirection(target) {\n  //@ts-ignore\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\nfunction _generateId(el) {\n  let str = el.tagName + el.className + el.src + el.href + el.textContent,\n    i = str.length,\n    sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n\n  let inputs = root.getElementsByTagName(\"input\");\n  let idx = inputs.length;\n\n  while (idx--) {\n    let el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n}\n\n// Fixed #973:\nif (documentExists) {\n  on(document, \"touchmove\", function (evt) {\n    //@ts-ignore\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n}\n\n// Export utils\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function (el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild,\n};\n\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\nSortable.get = function (element) {\n  return element[expando];\n};\n\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\nSortable.mount = function (...plugins) {\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n\n  plugins.forEach((plugin) => {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw `Sortable: Mounted plugin must be a constructor function, not ${{}.toString.call(\n        plugin\n      )}`;\n    }\n    if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };\n\n    PluginManager.mount(plugin);\n  });\n};\n\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n};\n\n// Export\nSortable.version = version;\n\nexport default Sortable;\n","import { toggleClass, index } from \"../../../utils/src\";\n\nlet lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: \"sortable-swap-highlight\",\n    };\n  }\n\n  Swap.prototype = {\n    dragStart({ dragEl }) {\n      lastSwapEl = dragEl;\n    },\n    dragOverValid({\n      completed,\n      target,\n      onMove,\n      activeSortable,\n      changed,\n      cancel,\n    }) {\n      if (!activeSortable.options.swap) return;\n      let el = this.sortable.el,\n        options = this.options;\n      if (target && target !== el) {\n        let prevSwapEl = lastSwapEl;\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n      changed();\n\n      completed(true);\n      cancel();\n    },\n    drop({ activeSortable, putSortable, dragEl }) {\n      let toSortable = putSortable || this.sortable;\n      let options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n      if (\n        lastSwapEl &&\n        (options.swap || (putSortable && putSortable.options.swap))\n      ) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable)\n            activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling() {\n      lastSwapEl = null;\n    },\n  };\n\n  return Object.assign(Swap, {\n    pluginName: \"swap\",\n    eventProperties() {\n      return {\n        swapItem: lastSwapEl,\n      };\n    },\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  let p1 = n1.parentNode,\n    p2 = n2.parentNode,\n    i1,\n    i2;\n\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n\n  //@ts-ignore\n  i1 = index(n1);\n  //@ts-ignore\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nexport default SwapPlugin;\n","import {\n  getRect,\n  css,\n  matrix,\n  isRectEqual,\n  indexOfObject,\n} from \"../../utils/src\";\nimport * as Sortable from \"./Sortable\";\n\nexport default function AnimationStateManager() {\n  let animationStates = [],\n    animationCallbackId;\n\n  return {\n    captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      let children = [].slice.call(this.el.children);\n\n      children.forEach((child) => {\n        //@ts-ignore\n        if (css(child, \"display\") === \"none\" || child === Sortable.ghost)\n          return;\n        animationStates.push({\n          target: child,\n          //@ts-ignore\n          rect: getRect(child),\n        });\n        let fromRect = { ...animationStates[animationStates.length - 1].rect };\n\n        // If animating: compensate for current animation\n        if (child.thisAnimationDuration) {\n          let childMatrix = matrix(child, true);\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n\n    addAnimationState(state) {\n      animationStates.push(state);\n    },\n\n    removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, { target }), 1);\n    },\n\n    animateAll(callback) {\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === \"function\") callback();\n        return;\n      }\n\n      let animating = false,\n        animationTime = 0;\n\n      animationStates.forEach((state) => {\n        let time = 0,\n          animatingThis = false,\n          target = state.target,\n          fromRect = target.fromRect,\n          //@ts-ignore\n          toRect = getRect(target),\n          prevFromRect = target.prevFromRect,\n          prevToRect = target.prevToRect,\n          animatingRect = state.rect,\n          targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (\n            isRectEqual(prevFromRect, toRect) &&\n            !isRectEqual(fromRect, toRect) &&\n            // Make sure animatingRect is on line between toRect & fromRect\n            (animatingRect.top - toRect.top) /\n              (animatingRect.left - toRect.left) ===\n              (fromRect.top - toRect.top) / (fromRect.left - toRect.left)\n          ) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(\n              animatingRect,\n              prevFromRect,\n              prevToRect,\n              this.options\n            );\n          }\n        }\n\n        // if fromRect != toRect: animate\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = this.options.animation;\n          }\n          this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n\n      clearTimeout(animationCallbackId);\n      if (!animating) {\n        if (typeof callback === \"function\") callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === \"function\") callback();\n        }, animationTime);\n      }\n      animationStates = [];\n    },\n\n    animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, \"transition\", \"\");\n        css(target, \"transform\", \"\");\n        //@ts-ignore\n        let elMatrix = matrix(this.el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d,\n          translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n          translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n\n        css(\n          target,\n          \"transform\",\n          \"translate3d(\" + translateX + \"px,\" + translateY + \"px,0)\"\n        );\n\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(\n          target,\n          \"transition\",\n          \"transform \" +\n            duration +\n            \"ms\" +\n            (this.options.easing ? \" \" + this.options.easing : \"\")\n        );\n        css(target, \"transform\", \"translate3d(0,0,0)\");\n        typeof target.animated === \"number\" && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, \"transition\", \"\");\n          css(target, \"transform\", \"\");\n          target.animated = false;\n\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    },\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return (\n    (Math.sqrt(\n      Math.pow(fromRect.top - animatingRect.top, 2) +\n        Math.pow(fromRect.left - animatingRect.left, 2)\n    ) /\n      Math.sqrt(\n        Math.pow(fromRect.top - toRect.top, 2) +\n          Math.pow(fromRect.left - toRect.left, 2)\n      )) *\n    options.animation\n  );\n}\n","import {\n  toggleClass,\n  getRect,\n  index,\n  closest,\n  on,\n  off,\n  clone,\n  css,\n  setRect,\n  unsetRect,\n  matrix,\n  expando,\n} from \"../../../utils/src\";\n\nimport dispatchEvent from \"../../../sortable/src/EventDispatcher\";\n\nlet multiDragElements = [],\n  multiDragClones = [],\n  lastMultiDragSelect, // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n  initialFolding = false, // Initial multi-drag fold when drag started\n  folding = false, // Folding any other time\n  dragStarted = false,\n  dragEl,\n  clonesFromRect,\n  clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, \"pointerup\", this._deselectMultiDrag);\n    } else {\n      on(document, \"mouseup\", this._deselectMultiDrag);\n      on(document, \"touchend\", this._deselectMultiDrag);\n    }\n\n    on(document, \"keydown\", this._checkKeyDown);\n    on(document, \"keyup\", this._checkKeyUp);\n\n    this.defaults = {\n      selectedClass: \"sortable-selected\",\n      multiDragKey: null,\n      setData(dataTransfer, dragEl) {\n        let data = \"\";\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach((multiDragElement, i) => {\n            data += (!i ? \"\" : \", \") + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n        dataTransfer.setData(\"Text\", data);\n      },\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n\n    delayStartGlobal({ dragEl: dragged }) {\n      dragEl = dragged;\n    },\n\n    delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl);\n    },\n\n    setupClone({ sortable, cancel }) {\n      if (!this.isMultiDrag) return;\n      for (let i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style[\"will-change\"] = \"\";\n\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl &&\n          toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n      cancel();\n    },\n\n    clone({ sortable, rootEl, dispatchSortableEvent, cancel }) {\n      if (!this.isMultiDrag) return;\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent(\"clone\");\n\n          cancel();\n        }\n      }\n    },\n\n    showClone({ cloneNowShown, rootEl, cancel }) {\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"\");\n      });\n\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n\n    hideClone({ sortable, cloneNowHidden, cancel }) {\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"none\");\n        if (this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n\n    dragStartGlobal({ sortable }) {\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach((multiDragElement) => {\n        //@ts-ignore\n        multiDragElement.sortableIndex = index(multiDragElement);\n      });\n\n      // Sort multi-drag elements\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n\n    dragStarted({ sortable }) {\n      if (!this.isMultiDrag) return;\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            css(multiDragElement, \"position\", \"absolute\");\n          });\n\n          //@ts-ignore\n          let dragRect = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRect);\n          });\n\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(() => {\n        folding = false;\n        initialFolding = false;\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n        }\n\n        // Remove all auxiliary multidrag items from el, if sorting enabled\n        if (this.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n\n    dragOver({ target, completed, cancel }) {\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n\n    revert({ fromSortable, rootEl, sortable, dragRect }) {\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach((multiDragElement) => {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            //@ts-ignore\n            rect: folding ? getRect(multiDragElement) : dragRect,\n          });\n\n          unsetRect(multiDragElement);\n\n          multiDragElement.fromRect = dragRect;\n\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n\n    dragOverCompleted({\n      sortable,\n      isOwner,\n      insertion,\n      activeSortable,\n      parentEl,\n      putSortable,\n    }) {\n      let options = this.options;\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false;\n        // If leaving sort:false root, or already folding - Fold to new location\n        if (\n          options.animation &&\n          multiDragElements.length > 1 &&\n          (folding ||\n            (!isOwner && !activeSortable.options.sort && !putSortable))\n        ) {\n          //@ts-ignore\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          let dragRectAbsolute = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRectAbsolute);\n\n            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n            parentEl.appendChild(multiDragElement);\n          });\n\n          folding = true;\n        }\n\n        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            let clonesHiddenBefore = clonesHidden;\n            activeSortable._showClone(sortable);\n\n            // Unfold animation for clones if showing from hidden\n            if (\n              activeSortable.options.animation &&\n              !clonesHidden &&\n              clonesHiddenBefore\n            ) {\n              multiDragClones.forEach((clone) => {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect,\n                });\n\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n\n    dragOverAnimationCapture({ dragRect, isOwner, activeSortable }) {\n      multiDragElements.forEach((multiDragElement) => {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (\n        activeSortable.options.animation &&\n        !isOwner &&\n        activeSortable.multiDrag.isMultiDrag\n      ) {\n        clonesFromRect = Object.assign({}, dragRect);\n        let dragMatrix = matrix(dragEl, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n\n    dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n\n    drop({\n      originalEvent: evt,\n      rootEl,\n      parentEl,\n      sortable,\n      dispatchSortableEvent,\n      oldIndex,\n      putSortable,\n    }) {\n      let toSortable = putSortable || this.sortable;\n\n      if (!evt) return;\n\n      let options = this.options,\n        children = parentEl.children;\n\n      // Multi-drag selection\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n        toggleClass(\n          dragEl,\n          options.selectedClass,\n          !~multiDragElements.indexOf(dragEl)\n        );\n\n        if (!~multiDragElements.indexOf(dragEl)) {\n          multiDragElements.push(dragEl);\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"select\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n\n          // Modifier activated, select from last to dragEl\n          if (\n            evt.shiftKey &&\n            lastMultiDragSelect &&\n            sortable.el.contains(lastMultiDragSelect)\n          ) {\n            //@ts-ignore\n            let lastIndex = index(lastMultiDragSelect),\n              //@ts-ignore\n              currentIndex = index(dragEl);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              let n, i;\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n\n                dispatchEvent({\n                  sortable,\n                  rootEl,\n                  name: \"select\",\n                  targetEl: children[i],\n                  //@ts-ignore\n                  originalEvt: evt,\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"deselect\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n        }\n      }\n\n      // Multi-drag drop\n      if (dragStarted && this.isMultiDrag) {\n        // Do not \"unfold\" after around dragEl if reverted\n        if (\n          (parentEl[expando].options.sort || parentEl !== rootEl) &&\n          multiDragElements.length > 1\n        ) {\n          //@ts-ignore\n          let dragRect = getRect(dragEl),\n            multiDragIndex = index(\n              dragEl,\n              \":not(.\" + this.options.selectedClass + \")\"\n            );\n\n          if (!initialFolding && options.animation)\n            dragEl.thisAnimationDuration = null;\n\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl.fromRect = dragRect;\n              multiDragElements.forEach((multiDragElement) => {\n                multiDragElement.thisAnimationDuration = null;\n                if (multiDragElement !== dragEl) {\n                  //@ts-ignore\n                  let rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect;\n\n                  // Prepare unfold animation\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect,\n                  });\n                }\n              });\n            }\n\n            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n            removeMultiDragElements();\n\n            multiDragElements.forEach((multiDragElement) => {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(\n                  multiDragElement,\n                  children[multiDragIndex]\n                );\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n              multiDragIndex++;\n            });\n\n            // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n            //@ts-ignore\n            if (oldIndex === index(dragEl)) {\n              let update = false;\n              multiDragElements.forEach((multiDragElement) => {\n                //@ts-ignore\n                if (\n                  //@ts-ignore\n                  multiDragElement.sortableIndex !== index(multiDragElement)\n                ) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent(\"update\");\n              }\n            }\n          }\n\n          // Must be done after capturing individual rects (scroll bar)\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      }\n\n      // Remove clones if necessary\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        multiDragClones.forEach((clone) => {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n\n    nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n\n    destroyGlobal() {\n      this._deselectMultiDrag();\n      off(document, \"pointerup\", this._deselectMultiDrag);\n      off(document, \"mouseup\", this._deselectMultiDrag);\n      off(document, \"touchend\", this._deselectMultiDrag);\n\n      off(document, \"keydown\", this._checkKeyDown);\n      off(document, \"keyup\", this._checkKeyUp);\n    },\n\n    _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return;\n\n      // Only deselect if selection is in this sortable\n      if (multiDragSortable !== this.sortable) return;\n\n      // Only deselect if target is not item in this sortable\n      if (\n        evt &&\n        closest(evt.target, this.options.draggable, this.sortable.el, false)\n      )\n        return;\n\n      // Only deselect if left click\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        let el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: \"deselect\",\n          //@ts-ignore\n          targetEl: el,\n          //@ts-ignore\n          originalEvt: evt,\n        });\n      }\n    },\n\n    _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n\n    _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    },\n  };\n\n  return Object.assign(MultiDrag, {\n    // Static methods & properties\n    pluginName: \"multiDrag\",\n    utils: {\n      /**\n       * Selects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be selected\n       */\n      select(el) {\n        let sortable = el.parentNode[expando];\n        if (\n          !sortable ||\n          !sortable.options.multiDrag ||\n          ~multiDragElements.indexOf(el)\n        )\n          return;\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n          multiDragSortable = sortable;\n        }\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n      /**\n       * Deselects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be deselected\n       */\n      deselect(el) {\n        let sortable = el.parentNode[expando],\n          index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      },\n    },\n    eventProperties() {\n      const oldIndicies = [],\n        newIndicies = [];\n\n      multiDragElements.forEach((multiDragElement) => {\n        oldIndicies.push({\n          multiDragElement,\n          index: multiDragElement.sortableIndex,\n        });\n\n        // multiDragElements will already be sorted if folding\n        let newIndex;\n        if (folding && multiDragElement !== dragEl) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(\n            multiDragElement,\n            \":not(.\" + this.options.selectedClass + \")\"\n          );\n        } else {\n          //@ts-ignore\n          newIndex = index(multiDragElement);\n        }\n        newIndicies.push({\n          multiDragElement,\n          index: newIndex,\n        });\n      });\n      return {\n        items: [...multiDragElements],\n        clones: [...multiDragClones],\n        oldIndicies,\n        newIndicies,\n      };\n    },\n    optionListeners: {\n      multiDragKey(key) {\n        key = key.toLowerCase();\n        if (key === \"ctrl\") {\n          key = \"Control\";\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n        return key;\n      },\n    },\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach((multiDragElement, i) => {\n    let target =\n      rootEl.children[\n        multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)\n      ];\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n\n/**\n * Insert multi-drag clones\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\n * @param  {HTMLElement} rootEl\n */\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach((clone, i) => {\n    let target =\n      rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach((multiDragElement) => {\n    if (multiDragElement === dragEl) return;\n    multiDragElement.parentNode &&\n      multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nexport default MultiDragPlugin;\n","import { getChild } from \"../../../utils/src\";\n\nconst drop = function ({\n  originalEvent,\n  putSortable,\n  dragEl,\n  activeSortable,\n  dispatchSortableEvent,\n  hideGhostForTarget,\n  unhideGhostForTarget,\n}) {\n  if (!originalEvent) return;\n  let toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  let touch =\n    originalEvent.changedTouches && originalEvent.changedTouches.length\n      ? originalEvent.changedTouches[0]\n      : originalEvent;\n  let target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent(\"spill\");\n    this.onSpill({ dragEl, putSortable });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart({ oldDraggableIndex }) {\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill({ dragEl, putSortable }) {\n    this.sortable.captureAnimationState();\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n    let nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n    this.sortable.animateAll();\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop,\n};\n\nObject.assign(Revert, {\n  pluginName: \"revertOnSpill\",\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill({ dragEl, putSortable }) {\n    const parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop,\n};\n\nObject.assign(Remove, {\n  pluginName: \"removeOnSpill\",\n});\n\nexport default [Remove, Revert];\n\nexport { Remove as RemoveOnSpill, Revert as RevertOnSpill };\n","import {\n  on,\n  off,\n  css,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  getParentAutoScrollElement,\n  expando,\n  getRect,\n  getWindowScrollingElement,\n  Edge,\n  IE11OrLess,\n  Safari,\n} from \"../../../utils/src\";\n\nimport Sortable from \"../../../sortable/src/Sortable\";\n\nlet autoScrolls = [],\n  scrollEl,\n  scrollRootEl,\n  scrolling = false,\n  lastAutoScrollX,\n  lastAutoScrollY,\n  touchEvt,\n  pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true,\n    };\n\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted({ originalEvent }) {\n      if (this.sortable.nativeDraggable) {\n        on(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, \"pointermove\", this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, \"touchmove\", this._handleFallbackAutoScroll);\n        } else {\n          on(document, \"mousemove\", this._handleFallbackAutoScroll);\n        }\n      }\n    },\n\n    dragOverCompleted({ originalEvent }) {\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n\n    drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        off(document, \"pointermove\", this._handleFallbackAutoScroll);\n        off(document, \"touchmove\", this._handleFallbackAutoScroll);\n        off(document, \"mousemove\", this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n\n    nulling() {\n      touchEvt = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n\n      autoScrolls.length = 0;\n    },\n\n    _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n\n    _handleAutoScroll(evt, fallback) {\n      const x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        elem = document.elementFromPoint(x, y);\n\n      touchEvt = evt;\n\n      // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n      if (fallback || Edge || IE11OrLess || Safari) {\n        //@ts-ignore\n        autoScroll(evt, this.options, elem, fallback);\n\n        // Listener for pointer element change\n        let ogElemScroller = getParentAutoScrollElement(elem, true);\n        if (\n          scrolling &&\n          (!pointerElemChangedInterval ||\n            x !== lastAutoScrollX ||\n            y !== lastAutoScrollY)\n        ) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval();\n          // Detect for pointer elem change, emulating native DnD behaviour\n          pointerElemChangedInterval = setInterval(() => {\n            let newElem = getParentAutoScrollElement(\n              document.elementFromPoint(x, y),\n              true\n            );\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n            //@ts-ignore\n            autoScroll(evt, this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (\n          !this.options.bubbleScroll ||\n          getParentAutoScrollElement(elem, true) === getWindowScrollingElement()\n        ) {\n          clearAutoScrolls();\n          return;\n        }\n        autoScroll(\n          //@ts-ignore\n          evt,\n          this.options,\n          getParentAutoScrollElement(elem, false),\n          false\n        );\n      }\n    },\n  };\n\n  return Object.assign(AutoScroll, {\n    pluginName: \"scroll\",\n    initializeByDefault: true,\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nconst autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  const x = (evt.touches ? evt.touches[0] : evt).clientX,\n    y = (evt.touches ? evt.touches[0] : evt).clientY,\n    sens = options.scrollSensitivity,\n    speed = options.scrollSpeed,\n    winScroller = getWindowScrollingElement();\n\n  let scrollThisInstance = false,\n    scrollCustomFn;\n\n  // New scroll root, set scrollEl\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n\n    clearAutoScrolls();\n\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  let layersOut = 0;\n  let currentParent = scrollEl;\n  do {\n    let el = currentParent,\n      //@ts-ignore\n      rect = getRect(el),\n      top = rect.top,\n      bottom = rect.bottom,\n      left = rect.left,\n      right = rect.right,\n      width = rect.width,\n      height = rect.height,\n      canScrollX,\n      canScrollY,\n      scrollWidth = el.scrollWidth,\n      scrollHeight = el.scrollHeight,\n      //@ts-ignore\n      elCSS = css(el),\n      scrollPosX = el.scrollLeft,\n      scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" ||\n          elCSS.overflowX === \"scroll\" ||\n          elCSS.overflowX === \"visible\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" ||\n          elCSS.overflowY === \"scroll\" ||\n          elCSS.overflowY === \"visible\");\n    } else {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" || elCSS.overflowX === \"scroll\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" || elCSS.overflowY === \"scroll\");\n    }\n\n    let vx =\n      canScrollX &&\n      //@ts-ignore\n      (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) -\n        //@ts-ignore\n        (Math.abs(left - x) <= sens && !!scrollPosX);\n    let vy =\n      canScrollY &&\n      //@ts-ignore\n      (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) -\n        //@ts-ignore\n        (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (let i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (\n      autoScrolls[layersOut].vx != vx ||\n      autoScrolls[layersOut].vy != vy ||\n      autoScrolls[layersOut].el !== el\n    ) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n        autoScrolls[layersOut].pid = setInterval(\n          function () {\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n            if (isFallback && this.layer === 0) {\n              //@ts-ignore\n              Sortable.active._onTouchMove(touchEvt); // To move ghost if it is positioned absolutely\n            }\n            let scrollOffsetY = autoScrolls[this.layer].vy\n              ? autoScrolls[this.layer].vy * speed\n              : 0;\n            let scrollOffsetX = autoScrolls[this.layer].vx\n              ? autoScrolls[this.layer].vx * speed\n              : 0;\n\n            if (typeof scrollCustomFn === \"function\") {\n              if (\n                scrollCustomFn.call(\n                  //@ts-ignore\n                  Sortable.dragged.parentNode[expando],\n                  scrollOffsetX,\n                  scrollOffsetY,\n                  evt,\n                  touchEvt,\n                  autoScrolls[this.layer].el\n                ) !== \"continue\"\n              ) {\n                return;\n              }\n            }\n\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n          }.bind({ layer: layersOut }),\n          24\n        );\n      }\n    }\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nexport default AutoScrollPlugin;\n","import Sortable from \"../../sortable/src/Sortable\";\nimport Swap from \"../../plugins/swap/src\";\nimport MultiDrag from \"../../plugins/multi-drag/src\";\nimport { RemoveOnSpill, RevertOnSpill } from \"../../plugins/on-spill/src\";\nimport AutoScroll from \"../../plugins/auto-scroll/src\";\n\n//@ts-ignore\nSortable.mount(new AutoScroll());\nSortable.mount(RemoveOnSpill, RevertOnSpill);\n//@ts-ignore\nSortable.mount(new Swap());\n//@ts-ignore\nSortable.mount(new MultiDrag());\n\nexport default Sortable;\nexport { Sortable };\n","import _extends from \"@babel/runtime/helpers/extends\";\nimport * as React from 'react';\nimport { StyledIconBase } from '@styled-icons/styled-icon';\nexport var Edit = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /*#__PURE__*/React.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 576 512\"\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    fill: \"currentColor\",\n    d: \"M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1 0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7 0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174L402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7l-43.2-43.2c-4.1-4.1-10.8-4.1-14.8 0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z\"\n  }));\n});\nEdit.displayName = 'Edit';\nexport var EditDimensions = {\n  height: 512,\n  width: 576\n};","import _extends from \"@babel/runtime/helpers/extends\";\nimport * as React from 'react';\nimport { StyledIconBase } from '@styled-icons/styled-icon';\nexport var Trash = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /*#__PURE__*/React.createElement(StyledIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 448 512\"\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    fill: \"currentColor\",\n    d: \"M432 32H312l-9.4-18.7A24 24 0 00281.1 0H166.8a23.72 23.72 0 00-21.4 13.3L136 32H16A16 16 0 000 48v32a16 16 0 0016 16h416a16 16 0 0016-16V48a16 16 0 00-16-16zM53.2 467a48 48 0 0047.9 45h245.8a48 48 0 0047.9-45L416 128H32z\"\n  }));\n});\nTrash.displayName = 'Trash';\nexport var TrashDimensions = {\n  height: 512,\n  width: 448\n};"],"sourceRoot":""}